# UDP协议头
## UDP端口号
由于很多软件需要用到 UDP 协议,所以 UDP 协议必须通过某个标志用以区分不同的程序所需要的数据包。端口号的功能就在于此,例如某一个 UDP 程序 A 在系统中注册了3000端口,那么,以后从外面传进来的目的端口号为3000的 UDP 包都会交给该程序。端 口号理论上可以有2^16这么多。因为它的长 度是16个 bit。
## UDP 检验和
这是一个可选的选项,并不是所有的系统都对 UDP 数据包加以检验和数据(相对 TCP 协议的必须来说),但是 RFC 中标准要求, 发送端应该计算检验和  
UDP检验和覆盖UDP协议头和数据,这和IP的检验和是不同的,IP协议的检验和只是覆盖IP数据头,并不覆盖所有的数据。UDP和TCP都包含一个伪首部,这是为了计算检验和而摄制的。伪首部甚至还包含 IP 地址这样的 IP 协议里面都有的信息,目的是 让 UDP 两次检查数据是否已经正确到达目的地。 如果发送端没有打开检验和选项,而接收端计算检验和有差错,那么 UDP 数据将会 被悄悄的丢掉(不保证送达),而不产生任何差错报文。  
## UDP 长度
UDP的长度被IP层限制。但是一般网络在传送的时候,一次一般传送不了那么长的协议(涉及到 MTU 的问 题),就只好对数据 分片,当然,这些是对 UDP 等上级协议透明的,UDP 不需要关心 IP 协议层对数据如何分片,下一个章节将会稍 微讨论一些分片的策略。  
UDP 和 ARP 之间的交互式用  
这是不常被人注意到的一个细节,这是针对一些系统地实现来说的。当 ARP 缓存还是空的时候。UDP 在被发送之前一定要发送一个 ARP 请求来获得目的 主机的 MAC 地址,如果这个 UDP 的数据包足够大,大到 IP 层一定要对其进行分片的时候,想象中,该 UDP 数据包的第一个分片会发出一个 ARP 查询请求, 所有的分片都辉等到这个查询完成以后再发送。事实上是这样吗?  
结果是,某些系统会让每一个分片都发送一个 ARP 查询,所有的分片都在等待,但是接受到第一个回应的时候,主机却只发送了 最后一个数据片而抛弃了其 他,这实在是让人匪夷所思。这样,因为分片的数据不能被及时组装,接受主机将会在一段时间内将永远 无法组装的 IP 数据包抛弃,并且发送组装超时的 ICMP 报文(其实很多系统不产生这个差错),以保证接受主机自己的接收端缓存不 被那些永远得不到组装的分片满。
## ICMP 源站抑制差错
当目标主机的处理速度赶不上数据接收的速度,因为接受主机的 IP 层缓存会被占满,所以主机就会发出一个“我受不了”的一个 ICMP 报文。
